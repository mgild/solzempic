//! IDL (Interface Definition Language) generation for Solana programs.
//!
//! This module provides utilities to convert the compile-time instruction metadata
//! generated by solzempic macros into JSON format compatible with Anchor's IDL spec.
//!
//! # Usage
//!
//! ```ignore
//! // In your lib.rs, after #[SolzempicEntrypoint] generates IDL_INSTRUCTIONS:
//! #[cfg(feature = "idl")]
//! pub fn generate_idl() -> String {
//!     solzempic::idl::to_json(
//!         "YourProgram11111111111111111111111111111111",
//!         "your_program",
//!         "0.1.0",
//!         IDL_INSTRUCTIONS,
//!     )
//! }
//! ```

use alloc::string::{String, ToString};
use alloc::format;
use alloc::vec::Vec;
use crate::{InstructionMeta, AccountTypeMeta};

/// Configuration for IDL generation
pub struct IdlConfig<'a> {
    /// Program address (base58 string)
    pub address: &'a str,
    /// Program name (snake_case)
    pub name: &'a str,
    /// Program version (semver)
    pub version: &'a str,
}

/// Generate JSON IDL from instruction metadata.
///
/// Returns a JSON string in Anchor IDL format.
pub fn to_json(
    address: &str,
    name: &str,
    version: &str,
    instructions: &[InstructionMeta],
) -> String {
    let mut json = String::with_capacity(64 * 1024);

    json.push_str("{\n");
    json.push_str(&format!("  \"address\": \"{}\",\n", address));
    json.push_str("  \"metadata\": {\n");
    json.push_str(&format!("    \"name\": \"{}\",\n", name));
    json.push_str(&format!("    \"version\": \"{}\",\n", version));
    json.push_str("    \"spec\": \"0.1.0\"\n");
    json.push_str("  },\n");

    // Instructions
    json.push_str("  \"instructions\": [\n");
    for (i, instr) in instructions.iter().enumerate() {
        json.push_str("    {\n");
        json.push_str(&format!("      \"name\": \"{}\",\n", to_camel_case(instr.name)));
        json.push_str(&format!("      \"discriminator\": [{}],\n", instr.discriminator));

        // Accounts
        json.push_str("      \"accounts\": [\n");
        for (j, acc) in instr.accounts.iter().enumerate() {
            json.push_str("        {\n");
            json.push_str(&format!("          \"name\": \"{}\",\n", to_camel_case(acc.name)));
            json.push_str(&format!("          \"isMut\": {},\n", acc.is_writable));
            json.push_str(&format!("          \"isSigner\": {},\n", acc.is_signer));
            json.push_str("          \"isOptional\": false\n");
            json.push_str("        }");
            if j < instr.accounts.len() - 1 {
                json.push(',');
            }
            json.push('\n');
        }
        json.push_str("      ],\n");

        // Args
        json.push_str("      \"args\": [\n");
        for (j, param) in instr.params.iter().enumerate() {
            json.push_str("        {\n");
            json.push_str(&format!("          \"name\": \"{}\",\n", to_camel_case(param.name)));
            json.push_str(&format!("          \"type\": {}\n", rust_type_to_idl_json(param.type_name)));
            json.push_str("        }");
            if j < instr.params.len() - 1 {
                json.push(',');
            }
            json.push('\n');
        }
        json.push_str("      ]\n");

        json.push_str("    }");
        if i < instructions.len() - 1 {
            json.push(',');
        }
        json.push('\n');
    }
    json.push_str("  ],\n");

    // Empty sections for accounts, types, errors (use to_json_full for populated sections)
    json.push_str("  \"accounts\": [],\n");
    json.push_str("  \"types\": [],\n");
    json.push_str("  \"errors\": []\n");
    json.push_str("}\n");

    json
}

/// Generate JSON IDL with auto-collected account types.
///
/// This function uses the `inventory` crate to automatically collect all account
/// types registered with `#[account(discriminator = ...)]` and generates the
/// complete IDL including the "accounts" and "types" sections.
///
/// # Example
///
/// ```ignore
/// // In your idl_export binary:
/// fn main() {
///     let json = solzempic::idl::to_json_with_accounts(
///         "YourProgram11111111111111111111111111111111",
///         "your_program",
///         "0.1.0",
///         IDL_INSTRUCTIONS,
///     );
///     println!("{}", json);
/// }
/// ```
#[cfg(feature = "idl")]
pub fn to_json_with_accounts(
    address: &str,
    name: &str,
    version: &str,
    instructions: &[InstructionMeta],
) -> String {
    // Auto-collect accounts via inventory
    let accounts: Vec<&AccountTypeMeta> = crate::inventory::iter::<&'static AccountTypeMeta>()
        .copied()
        .collect();

    to_json_full(address, name, version, instructions, &accounts)
}

/// Generate JSON IDL with explicit account types.
///
/// Use this if you want to manually specify account types rather than using
/// automatic collection.
pub fn to_json_full(
    address: &str,
    name: &str,
    version: &str,
    instructions: &[InstructionMeta],
    accounts: &[&AccountTypeMeta],
) -> String {
    let mut json = String::with_capacity(128 * 1024);

    json.push_str("{\n");
    json.push_str(&format!("  \"address\": \"{}\",\n", address));
    json.push_str("  \"metadata\": {\n");
    json.push_str(&format!("    \"name\": \"{}\",\n", name));
    json.push_str(&format!("    \"version\": \"{}\",\n", version));
    json.push_str("    \"spec\": \"0.1.0\"\n");
    json.push_str("  },\n");

    // Instructions
    json.push_str("  \"instructions\": [\n");
    for (i, instr) in instructions.iter().enumerate() {
        json.push_str("    {\n");
        json.push_str(&format!("      \"name\": \"{}\",\n", to_camel_case(instr.name)));
        json.push_str(&format!("      \"discriminator\": [{}],\n", instr.discriminator));

        // Accounts
        json.push_str("      \"accounts\": [\n");
        for (j, acc) in instr.accounts.iter().enumerate() {
            json.push_str("        {\n");
            json.push_str(&format!("          \"name\": \"{}\",\n", to_camel_case(acc.name)));
            json.push_str(&format!("          \"isMut\": {},\n", acc.is_writable));
            json.push_str(&format!("          \"isSigner\": {},\n", acc.is_signer));
            json.push_str("          \"isOptional\": false\n");
            json.push_str("        }");
            if j < instr.accounts.len() - 1 {
                json.push(',');
            }
            json.push('\n');
        }
        json.push_str("      ],\n");

        // Args
        json.push_str("      \"args\": [\n");
        for (j, param) in instr.params.iter().enumerate() {
            json.push_str("        {\n");
            json.push_str(&format!("          \"name\": \"{}\",\n", to_camel_case(param.name)));
            json.push_str(&format!("          \"type\": {}\n", rust_type_to_idl_json(param.type_name)));
            json.push_str("        }");
            if j < instr.params.len() - 1 {
                json.push(',');
            }
            json.push('\n');
        }
        json.push_str("      ]\n");

        json.push_str("    }");
        if i < instructions.len() - 1 {
            json.push(',');
        }
        json.push('\n');
    }
    json.push_str("  ],\n");

    // Accounts section (discriminator registry)
    json.push_str("  \"accounts\": [\n");
    for (i, acc) in accounts.iter().enumerate() {
        json.push_str("    {\n");
        json.push_str(&format!("      \"name\": \"{}\",\n", acc.name));
        // 8-byte discriminator array with value in first byte
        json.push_str(&format!("      \"discriminator\": [{}, 0, 0, 0, 0, 0, 0, 0]\n", acc.discriminator));
        json.push_str("    }");
        if i < accounts.len() - 1 {
            json.push(',');
        }
        json.push('\n');
    }
    json.push_str("  ],\n");

    // Types section (full field definitions)
    json.push_str("  \"types\": [\n");
    for (i, acc) in accounts.iter().enumerate() {
        json.push_str("    {\n");
        json.push_str(&format!("      \"name\": \"{}\",\n", acc.name));
        json.push_str("      \"type\": {\n");
        json.push_str("        \"kind\": \"struct\",\n");
        json.push_str("        \"fields\": [\n");
        for (j, field) in acc.fields.iter().enumerate() {
            json.push_str("          {\n");
            json.push_str(&format!("            \"name\": \"{}\",\n", to_camel_case(field.name)));
            json.push_str(&format!("            \"type\": {}\n", rust_type_to_idl_json(field.type_name)));
            json.push_str("          }");
            if j < acc.fields.len() - 1 {
                json.push(',');
            }
            json.push('\n');
        }
        json.push_str("        ]\n");
        json.push_str("      }\n");
        json.push_str("    }");
        if i < accounts.len() - 1 {
            json.push(',');
        }
        json.push('\n');
    }
    json.push_str("  ],\n");

    json.push_str("  \"errors\": []\n");
    json.push_str("}\n");

    json
}

/// Convert snake_case to camelCase
fn to_camel_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    let mut capitalize_next = false;

    for c in s.chars() {
        if c == '_' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }

    // Convert first char to lowercase for camelCase
    if let Some(first) = result.chars().next() {
        let rest: String = result.chars().skip(1).collect();
        return first.to_lowercase().to_string() + &rest;
    }

    result
}

/// Convert Rust type names to Anchor IDL JSON type format
fn rust_type_to_idl_json(rust_type: &str) -> String {
    match rust_type {
        "u8" => "\"u8\"".to_string(),
        "u16" => "\"u16\"".to_string(),
        "u32" => "\"u32\"".to_string(),
        "u64" => "\"u64\"".to_string(),
        "u128" => "\"u128\"".to_string(),
        "i8" => "\"i8\"".to_string(),
        "i16" => "\"i16\"".to_string(),
        "i32" => "\"i32\"".to_string(),
        "i64" => "\"i64\"".to_string(),
        "i128" => "\"i128\"".to_string(),
        "bool" => "\"bool\"".to_string(),
        "Pubkey" | "solana_address::Address" | "Address" => "\"pubkey\"".to_string(),
        s if s.starts_with("[") && s.ends_with("]") => {
            // Parse array type "[T; N]"
            let inner = &s[1..s.len()-1];
            if let Some(semi_pos) = inner.rfind(';') {
                let elem_type = inner[..semi_pos].trim();
                let len_str = inner[semi_pos+1..].trim();

                // Try to parse length as literal number
                if let Ok(len) = len_str.parse::<usize>() {
                    let elem_json = rust_type_to_idl_json(elem_type);
                    format!("{{ \"array\": [{}, {}] }}", elem_json, len)
                } else {
                    // Length is a constant expression - treat as bytes for now
                    "\"bytes\"".to_string()
                }
            } else {
                "\"bytes\"".to_string()
            }
        }
        _ => format!("\"{}\"", rust_type),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_camel_case() {
        assert_eq!(to_camel_case("protocol_init"), "protocolInit");
        assert_eq!(to_camel_case("market_init"), "marketInit");
        assert_eq!(to_camel_case("ProtocolInit"), "protocolInit");
        assert_eq!(to_camel_case("payer"), "payer");
    }

    #[test]
    fn test_rust_type_to_idl_json() {
        assert_eq!(rust_type_to_idl_json("u64"), "\"u64\"");
        assert_eq!(rust_type_to_idl_json("[u8; 8]"), "{ \"array\": [\"u8\", 8] }");
        assert_eq!(rust_type_to_idl_json("Pubkey"), "\"pubkey\"");
    }
}
